/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#1ce984c2881bf9cff6e44566d2f9b0b9b0fd5038
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
let _initProto, _MatcherDecs, _GapNodeMatcherDecs, _ArrayNodeMatcherDecs, _NullNodeMatcherDecs, _PropertyMatcherDecs, _BasicNodeMatcherDecs, _CloseNodeMatcherDecs, _BooleanAttributeDecs, _MappingAttributeDecs, _StringMatcherDecs, _StringDecs, _RegexDecs, _ListDecs, _PunctuatorDecs, _AnyDecs;
import { re, spam as m } from '@bablr/boot';
import { Node, CoveredBy, InjectFrom, UnboundAttributes } from '@bablr/helpers/decorators';
import * as productions from '@bablr/helpers/productions';
import { e, eat, eatMatch, match, bindAttribute, fail } from '@bablr/helpers/grammar';
import * as Regex from '@bablr/language-en-regex-vm-pattern';
import * as CSTML from '@bablr/language-en-cstml';
import * as Space from '@bablr/language-en-blank-space';
import { notNull } from '@bablr/agast-helpers/tree';
export const canonicalURL = 'https://bablr.org/languages/core/en/spamex';
export const dependencies = {
  Regex,
  CSTML,
  Space
};
const {
  eatMatchTrivia
} = CSTML;
export const grammar = class SpamexGrammar {
  static {
    [_initProto] = _applyDecs(this, [[_MatcherDecs, 2, "Matcher"], [_GapNodeMatcherDecs, 2, "GapNodeMatcher"], [_ArrayNodeMatcherDecs, 2, "ArrayNodeMatcher"], [_NullNodeMatcherDecs, 2, "NullNodeMatcher"], [_PropertyMatcherDecs, 2, "PropertyMatcher"], [Node, 2, "ReferenceMatcher"], [_BasicNodeMatcherDecs, 2, "BasicNodeMatcher"], [Node, 2, "OpenNodeMatcher"], [_CloseNodeMatcherDecs, 2, "CloseNodeMatcher"], [_BooleanAttributeDecs, 2, "BooleanAttribute"], [_MappingAttributeDecs, 2, "MappingAttribute"], [_StringMatcherDecs, 2, "StringMatcher"], [_StringDecs, 2, "String"], [_RegexDecs, 2, "Regex"], [_ListDecs, 2, "List"], [_PunctuatorDecs, 2, "Punctuator"], [_AnyDecs, 2, "Any"]], []).e;
  }
  constructor() {
    _initProto(this);
  }
  *[(_MatcherDecs = CoveredBy('Expression'), _GapNodeMatcherDecs = [Node, CoveredBy('NodeMatcher')], _ArrayNodeMatcherDecs = [Node, CoveredBy('NodeMatcher')], _NullNodeMatcherDecs = [Node, CoveredBy('NodeMatcher')], _PropertyMatcherDecs = [Node, CoveredBy('Matcher')], _BasicNodeMatcherDecs = [Node, CoveredBy('NodeMatcher')], _CloseNodeMatcherDecs = [Node, CoveredBy('Matcher')], _BooleanAttributeDecs = [UnboundAttributes(['true']), Node, CoveredBy('Attribute')], _MappingAttributeDecs = [CoveredBy('Attribute'), Node], _StringMatcherDecs = [CoveredBy('Matcher'), CoveredBy('Expression')], _StringDecs = [CoveredBy('StringMatcher'), CoveredBy('Matcher'), CoveredBy('Expression'), Node], _RegexDecs = [CoveredBy('StringMatcher'), CoveredBy('Matcher'), CoveredBy('Expression'), Node], _ListDecs = InjectFrom(productions), _PunctuatorDecs = [Node, InjectFrom(productions)], _AnyDecs = InjectFrom(productions), "Matcher")]() {
    yield eat(m`<Any />`, e([m`<PropertyMatcher /[a-zA-Z.<]/ />`, m`<StringMatcher /[/'"]/ />`]));
  }
  *NodeMatcher() {
    yield eat(m`<Any />`, e([m`<GapNodeMatcher '<//>' />`, m`<BasicNodeMatcher '<' />`, m`<ArrayNodeMatcher '[' />`, m`<NullNodeMatcher 'null' />`]));
  }
  *GapNodeMatcher() {
    yield eat(m`sigilToken: <Punctuator '<//>' />`);
  }
  *ArrayNodeMatcher() {
    yield eat(m`sigilToken: <Punctuator '[]' />`);
  }
  *NullNodeMatcher() {
    yield eat(m`sigilToken: <Punctuator 'null' />`);
  }
  *PropertyMatcher() {
    yield eatMatch(m`refMatcher: <ReferenceMatcher />`);
    yield* eatMatchTrivia();
    yield eat(m`nodeMatcher: <BasicNodeMatcher />`);
  }
  *ReferenceMatcher() {
    let name;
    if (yield match('.')) {
      name = yield eat(m`name$: <*Punctuator '.' />`);
    } else {
      name = yield eatMatch(m`name$: <*CSTML:Identifier />`);
    }
    if (name && (yield eatMatch(m`openIndexToken: <*Punctuator '[' balanced=']' />`))) {
      yield* eatMatchTrivia();
      yield eatMatch(m`closeIndexToken: <*Punctuator ']' balancer />`);
    } else {
      yield eatMatch(m`closeIndexToken: null`);
    }
    yield* eatMatchTrivia();
    yield eatMatch(m`flags: <CSTML:ReferenceFlags />`);
    yield* eatMatchTrivia();
    yield eat(m`sigilToken: <*Punctuator ':' />`);
  }
  *BasicNodeMatcher() {
    let open = yield eat(m`open: <OpenNodeMatcher />`);
    const selfClosing = notNull(open.get('selfClosingTagToken'));
    if (selfClosing) {
      yield eat(m`children[]$: []`);
      yield eat(m`close: null`);
    } else {
      // TODO
      yield* eatMatchTrivia();
      yield eat(m`close: <CloseNodeMatcher />`);
    }
  }
  *OpenNodeMatcher() {
    yield eat(m`open: <*Punctuator '<' balancedSpan='Tag' balanced='>' />`);
    yield eat(m`flags: <CSTML:NodeFlags />`);
    if (yield eatMatch(m`<CSTML:TagType /[a-zA-Z'"\g]/ />`)) {
      // continue
    } else if (yield eatMatch(m`type$: <*Punctuator /[ \t]+|?/ />`)) {
      // continue
    } else {
      yield fail();
    }
    let sp = yield* eatMatchTrivia();
    if (sp && !(yield match(re`/\/$/`)) && (yield eatMatch(m`intrinsicValue$: <StringMatcher />`))) {
      sp = yield* eatMatchTrivia();
    }
    while (sp && (yield match(re`/!?[a-zA-Z]/`))) {
      yield eat(m`attributes[]: <Attribute />`);
      sp = yield* eatMatchTrivia();
    }
    yield eatMatch(m`selfClosingTagToken: <*Punctuator '/' />`);
    yield eat(m`close: <*Punctuator '>' balancer />`);
  }
  *CloseNodeMatcher() {
    yield eat(m`openToken: <*Punctuator '</' balanced='>' />`);
    yield eat(m`closeToken: <*Punctuator '>' balancer />`);
  }
  *Attributes() {
    yield eatMatch(m`<List />`, e({
      element: m`<Attribute />`,
      allowTrailingSeparator: false
    }));
  }
  *Attribute() {
    if (yield match(re`/[a-zA-Z]+\s*=/`)) {
      yield eat(m`<MappingAttribute />`);
    } else {
      yield eat(m`<BooleanAttribute />`);
    }
  }
  *BooleanAttribute() {
    if (yield eatMatch(m`negateToken: <*Punctuator '!' />`)) {
      yield bindAttribute('true', false);
    } else {
      yield bindAttribute('true', true);
    }
    yield eat(m`key$: <*CSTML:Identifier />`);
  }
  *MappingAttribute() {
    yield eat(m`key$: <*CSTML:Identifier />`);
    yield eat(m`mapOperator: <*Punctuator '=' />`);
    yield eat(m`value$: <CSTML:AttributeValue />`);
  }
  *StringMatcher() {
    if (yield match(re`/['"]/`)) {
      yield eat(m`<String />`);
    } else {
      yield eat(m`<Pattern />`);
    }
  }
  *String() {
    yield eat(m`<CSTML:String />`, null, e({
      suppressNode: e(true)
    }));
  }
  *Regex() {
    yield eat(m`<Regex:Pattern />`, null, e({
      suppressNode: e(true)
    }));
  }
  List() {}
  Punctuator() {}
  Any() {}
};