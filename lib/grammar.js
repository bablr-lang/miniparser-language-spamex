/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#504bb9fbdbabe4d9286f5687e8ce2e2d71e82fa2
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { interpolateArray as _interpolateArray, interpolateFragmentChildren as _interpolateFragmentChildren, interpolateString as _interpolateString } from "@bablr/agast-helpers/template";
import * as _l from "@bablr/agast-vm-helpers/languages";
import * as _t from "@bablr/agast-helpers/shorthand";
let _initProto, _MatcherDecs, _NodeMatcherDecs, _CloseNodeMatcherDecs, _BooleanAttributeDecs, _MappingAttributeDecs, _StringMatcherDecs, _StringDecs, _RegexDecs, _ListDecs, _PunctuatorDecs, _AnyDecs;
import { Node, CoveredBy, InjectFrom, UnboundAttributes } from '@bablr/helpers/decorators';
import * as productions from '@bablr/helpers/productions';
import * as Regex from '@bablr/language-en-regex-vm-pattern';
import * as CSTML from '@bablr/language-en-cstml';
import * as Space from '@bablr/language-en-blank-space';
import { notNull } from '@bablr/agast-helpers/tree';
export const canonicalURL = 'https://bablr.org/languages/core/en/spamex';
export const dependencies = {
  Regex,
  CSTML,
  Space
};
const {
  eatMatchTrivia
} = CSTML;
export const grammar = class SpamexGrammar {
  static {
    [_initProto] = _applyDecs(this, [[_MatcherDecs, 2, "Matcher"], [_NodeMatcherDecs, 2, "NodeMatcher"], [Node, 2, "OpenNodeMatcher"], [_CloseNodeMatcherDecs, 2, "CloseNodeMatcher"], [_BooleanAttributeDecs, 2, "BooleanAttribute"], [_MappingAttributeDecs, 2, "MappingAttribute"], [_StringMatcherDecs, 2, "StringMatcher"], [_StringDecs, 2, "String"], [_RegexDecs, 2, "Regex"], [_ListDecs, 2, "List"], [_PunctuatorDecs, 2, "Punctuator"], [_AnyDecs, 2, "Any"]], []).e;
  }
  constructor() {
    _initProto(this);
  }
  *[(_MatcherDecs = CoveredBy('Expression'), _NodeMatcherDecs = [Node, CoveredBy('Matcher')], _CloseNodeMatcherDecs = [Node, CoveredBy('Matcher')], _BooleanAttributeDecs = [UnboundAttributes(['true']), Node, CoveredBy('Attribute')], _MappingAttributeDecs = [CoveredBy('Attribute'), Node], _StringMatcherDecs = [CoveredBy('Matcher'), CoveredBy('Expression')], _StringDecs = [CoveredBy('StringMatcher'), CoveredBy('Matcher'), CoveredBy('Expression'), Node], _RegexDecs = [CoveredBy('StringMatcher'), CoveredBy('Matcher'), CoveredBy('Expression'), Node], _ListDecs = InjectFrom(productions), _PunctuatorDecs = [Node, InjectFrom(productions)], _AnyDecs = InjectFrom(productions), "Matcher")]() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [11, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "NodeMatcher"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("<")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [10, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`], [_t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
                segments: [_t.s_node(_l.CSTML, "Identifier", "CSTML")]
              }, {}),
              namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
              type: _t.s_node(_l.CSTML, "Identifier", "String"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [10, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`], [_t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
                segments: [_t.s_node(_l.CSTML, "Identifier", "Regex")]
              }, {}),
              namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
              type: _t.s_node(_l.CSTML, "Identifier", "Pattern"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("/")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *NodeMatcher() {
    let open = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "OpenNodeMatcher"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("open")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    const selfClosing = notNull(open.get('selfClosingTagToken'));
    if (selfClosing) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Array", [_t.ref`openToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
            closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("children[]$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      // TODO
      yield* eatMatchTrivia();
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "CloseNodeMatcher"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *OpenNodeMatcher() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [14, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr()], [_t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("<")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancedSpan"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Tag")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {}), _t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("open")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
              segments: [_t.s_node(_l.CSTML, "Identifier", "CSTML")]
            }, {}),
            namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
            type: _t.s_node(_l.CSTML, "Identifier", "Flags"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("flags")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [10, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`], [_t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
              segments: [_t.s_node(_l.CSTML, "Identifier", "CSTML")]
            }, {}),
            namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
            type: _t.s_node(_l.CSTML, "Identifier", "TagType"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "CharacterClass", [9, [[_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], [_t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`]]], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                    min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                    rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                    max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                  }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                    min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                    rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                    max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                  }, {}), _t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {}), _t.node(_l.Regex, "Gap", [_t.ref`escapeToken`, _t.ref`value`], {
                    escapeToken: _t.s_node(_l.Regex, "Punctuator", "\\"),
                    value: _t.s_node(_l.Regex, "Keyword", "g")
                  }, {})],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: false
                })]
              }, {})],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      // continue
    } else if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [9, [[_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`], [_t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`]]], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                  element: _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit(" ")], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\t")], {}, {
                      cooked: "\t"
                    }))], {}, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  }),
                  value: _t.s_node(_l.Regex, "Keyword", "+")
                }, {
                  min: 1,
                  max: Infinity,
                  greedy: true
                })]
              }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.lit("?")], {}, {})]
              }, {})],
              separators: [_t.s_node(_l.Regex, "Punctuator", "|")],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("type$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      // continue
    }
    let sp = yield* eatMatchTrivia();
    if (sp && !(yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\/")], {}, {
              cooked: "/"
            }))], {}, {}), _t.node(_l.Regex, "EndOfInputAssertion", [_t.ref`sigilToken`], {
              sigilToken: _t.s_node(_l.Regex, "Keyword", "$")
            }, {})]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) && (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "StringMatcher"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("intrinsicValue$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}))) {
      sp = yield* eatMatchTrivia();
    }
    while (sp && (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
              element: _t.node(_l.Regex, "Character", [_t.lit("!")], {}, {}),
              value: _t.s_node(_l.Regex, "Keyword", "?")
            }, {
              min: 0,
              max: 1,
              greedy: true
            }), _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
              }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
              }, {})],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}))) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Attribute"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("attributes[]")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      sp = yield* eatMatchTrivia();
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("/")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("selfClosingTagToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *CloseNodeMatcher() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("</")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "TagType"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Attributes() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "List"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Object", [9, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`properties[]`, _t.arr()], [_t.ref`properties[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`properties[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "{"),
          properties: [_t.node(_l.Instruction, "Property", [_t.ref`key`, _t.ref`mapToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`value`], {
            key: _t.node(_l.Instruction, "Literal", [_t.lit("element")], {}, {}),
            mapToken: _t.s_node(_l.Instruction, "Punctuator", ":"),
            value: _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "Attribute"),
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {})
          }, {}), _t.node(_l.Instruction, "Property", [_t.ref`key`, _t.ref`mapToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`value`], {
            key: _t.node(_l.Instruction, "Literal", [_t.lit("allowTrailingSeparator")], {}, {}),
            mapToken: _t.s_node(_l.Instruction, "Punctuator", ":"),
            value: _t.node(_l.Instruction, "Boolean", [_t.ref`sigilToken`], {
              sigilToken: _t.s_node(_l.Instruction, "Keyword", "false")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", "}")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Attribute() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
              element: _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                  min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                  rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                  max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                  min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                  rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                  max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                }, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
              }, {
                negate: false
              }),
              value: _t.s_node(_l.Regex, "Keyword", "+")
            }, {
              min: 1,
              max: Infinity,
              greedy: true
            }), _t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
              element: _t.node(_l.Regex, "SpaceCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                escapeToken: _t.s_node(_l.Regex, "Punctuator", "\\"),
                value: _t.s_node(_l.Regex, "Keyword", "s")
              }, {}),
              value: _t.s_node(_l.Regex, "Keyword", "*")
            }, {
              min: 0,
              max: Infinity,
              greedy: true
            }), _t.node(_l.Regex, "Character", [_t.lit("=")], {}, {})]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "MappingAttribute"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "BooleanAttribute"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *BooleanAttribute() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("!")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negateToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("true")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {}), _t.node(_l.Instruction, "Boolean", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "false")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("true")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {}), _t.node(_l.Instruction, "Boolean", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "true")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
              segments: [_t.s_node(_l.CSTML, "Identifier", "CSTML")]
            }, {}),
            namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
            type: _t.s_node(_l.CSTML, "Identifier", "Identifier"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("key$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *MappingAttribute() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
              segments: [_t.s_node(_l.CSTML, "Identifier", "CSTML")]
            }, {}),
            namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
            type: _t.s_node(_l.CSTML, "Identifier", "Identifier"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("key$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("=")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("mapOperator")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
              segments: [_t.s_node(_l.CSTML, "Identifier", "CSTML")]
            }, {}),
            namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
            type: _t.s_node(_l.CSTML, "Identifier", "AttributeValue"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *StringMatcher() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
                segments: [_t.s_node(_l.CSTML, "Identifier", "CSTML")]
              }, {}),
              namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
              type: _t.s_node(_l.CSTML, "Identifier", "String"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
                segments: [_t.s_node(_l.CSTML, "Identifier", "Regex")]
              }, {}),
              namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
              type: _t.s_node(_l.CSTML, "Identifier", "Pattern"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *String() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
              segments: [_t.s_node(_l.CSTML, "Identifier", "CSTML")]
            }, {}),
            namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
            type: _t.s_node(_l.CSTML, "Identifier", "String"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Regex() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("/")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("/")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("open")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
              segments: [_t.s_node(_l.CSTML, "Identifier", "Regex")]
            }, {}),
            namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
            type: _t.s_node(_l.CSTML, "Identifier", "Alternatives"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("alternatives[]$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("/")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
              segments: [_t.s_node(_l.CSTML, "Identifier", "Regex")]
            }, {}),
            namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
            type: _t.s_node(_l.CSTML, "Identifier", "Flags"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("flags$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  List() {}
  Punctuator() {}
  Any() {}
};